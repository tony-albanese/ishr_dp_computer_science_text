\chapter{System Fundamentals}
The world is a complex place full of complex objects that interact with each other. In order to understand these objects better, we group them into systems. Because this is a computer science course, we will focus our attention on computers.

I think it is obvious that a "computer" is a complex machine assembled from many individual parts that must function together properly in order to work. In the following sections, we will break the computer down into a system of parts and learn how to represent those parts with a block diagram. 

A block diagram is a tool that helps us to understand how all of the parts of complex system work together in a visual way. In doing so, we will only focus on the level of detail that we require for whatever purpose we have at the moment. In other words, we will abstract away the detail to make things more manageable.

\section{System Design Basics}

\subsection*{The Components of a Computer System}
We will begin by looking at a computer system from the most superficial and highest level. These components of a computer system are: hardware, software, peripherals,networks, and human resources.

\textbf{Hardware} consists of the physical components of the computer and include things such as the CPU, hard drive, chips, etc. \textbf{Software} consists of the binary programs that run on the hardware. \textbf{Peripherals} are devices that one attaches to a computer to enhance its function. Examples include cameras, disk drives, printers, modems, etc. Human resources consist of the human beings that interact with the computer system. 

\section{Computer Architecture}
In this section, we focus our attention on the computer hardware itself. Although the hardware is very complex and consists of thousands of parts, we will remain at a very abstract and high level and focus on the following components: 

\begin{itemize}
	\item The Central Processing Unit (CPU)
	\item The Arithmetic Logic Unit (ALU)
	\item The Control Unit (CU)
	\item The registers within the CPU
\end{itemize} 

\subsection*{The Central Processing Unit}
The CPU is the circuitry (not necessarily a single chip) that is responsible for carrying out the logical instructions, computations, and input/output functions in a computer program. 

\subsection*{The Arithmetic and Logic Unit}
The ALU is an electronic circuit (which can be found on a chip), that is responsible for arithmetic and bitwise operations on binary numbers. Remember that the primary purpose of a computer is to perform calculations. The ALU is responsible for carrying out these calculations. In addition, computers process logical operations like AND, OR, NOT etc. The ALU also handles performing these logical operations.

%Give an example of some logical operations.
%Link to CC Computer Science

\subsection*{The Control Unit}
The control unit is a bit of hardware (i.e. an electronic circuit) that controls what the CPU can access. In other words, the CPU is the circuit that does the actual hard work of calculation and executing instructions. The CU helps the CPU communicate with software and other hardware. For example, the CU will manage the communication between the input/output devices and the CPU. It also manages the timing of instructions the CPU receives and the output given so that this communication is coordinated and organized. It will also interpret instructions from these devices. 

%Write about the MAR and MDR

\subsection*{Registers} %Roll this definition into the CU section.
A register is a small piece of very fast memory available to the processor to speed up its operations. Commonly accessed values are stored in registers so the processor does not waste time accessing these values from slower forms of memory.

\subsection*{Primary Memory}
When people talk of computer memory they are usually talking about primary memory. In other words, when somebody says, " My computer has 8 GB RAM" they are talking about primary memory. Primary memory is the only area of memory that can be accessed by the CPU. What is the CPU looking for? Primary memory contains either instructions or data stored in a series of binary digits (bits, 1s and 0s). This data can be accessed randomly which means that the CPU can go to any memory address it needs to either fetch data or get an instruction. It would be analogous to going to any page in a book to get the information you are looking for. You don't need to read the entire book to read page 121. That is why this type of memory is called RAM or "Random Access Memory". The catch, though, is that the information stored in RAM is volatile. In other words, everything is memory is lost when the power is removed.

In contrast to RAM is ROM. ROM stands for "Read Only Memory". ROM chips contain instructions and data that is permanently written and cannot be changed. It used any time a set of permanent instructions or data is required. For example, instructions on loading the operating system at boot time are normally written on ROM chips. Also, early video games like those for the Atari, Nintendo Entertainment System, and Super Nintendo came on ROM cartridges because they were fast to load. Unfortunately, you could not save your progress so your game scores were lost when you shut off the system.

\subsection*{Cache Memory}
Imagine you have a textbook for Chemistry that is over 500 pages long. You notice that for the particular topic you are studying, you keep referring to the same information over and over again on only a few pages. Rather than try to find that information each time, you make a bookmark for the required pages in the book so that you can quickly go to the spot that you need.

When you study something else, you remove the bookmark.

Cache memory operates on a similar (although not the same principle). The hardware used for cache memory is much faster at reading and writing data than normal RAM. So if the processor needs a particular instruction or piece of data, it checks the cache memory first before looking to the RAM. If the required data in the cache is not there, then it is copied from RAM to cache where the processor then accesses it. This is much faster than just using RAM. You might ask why is not all memory cache memory if it so much faster? The answer is that cache memory is much more expensive. So the compromise is to use cache memory as a go-between the RAM and processor.

There are two types of cache memory. L1 cache is placed directly on the microprocessor whereas L2 is placed somewhere between the primary memory (RAM) and the microprocessor. 
%A little snippet on L1 vs L2 might be useful.

\subsection*{Machine Instruction Cycle}
It makes sense that the CPU has to execute instructions on a particular piece of data. But in order to keep things organized and coordinated, the process by which this occurs is orderly. The Machine Instruction Cycle encapsulates the steps that need to occur in order for the processor to execute a set of instructions.

\begin{enumerate}
	\item All of the instructions from the computer program as well as any data to be processed are located in primary memory (RAM). The first step is for the CPU to fetch the correct instruction located in memory. To do that, it sends the address of the RAM containing the instruction through the Memory Address Bus to primary memory. The instructions located at that address is copied into the data bus and sent to the Control Unit. 
	\item The next step is for the instruction to be decoded in the control unit. This is where the CPU is made aware of any additional data that may be required to execute the instruction. If other data is needed from the primary memory, the addresses of these data are placed in the memory bus and the data located at these addresses is sent back through the data bus to the CPU.
	\item The CPU then executes the instruction on any data (if required). If more data from primary memory is required, the addresses in memory that need to be accessed are sent to the memory address bus and the values at those addresses are returned to the CPU through the data bus.
	\item After execution, the CPU writes the result to primary memory. To do so, it sends the address where the data is to be stored through the memory address bus and the data itself through the data bus. The CPU then checks what the next instruction is and begins the cycle again.
\end{enumerate}
\section{Secondary Memory}
Primary memory is great. Not only is it (relatively) cheap, it is also very fast. There is however, one serious drawback and that is the fact that primary memory is volatile. That means that all of the information stored in RAM is lost when the computer powers down or when power is lost.
It is not a good idea to store data that is meant to be (relatively) permanent in volatile media. Imagine the chaos that would ensure if all of the customer and account data held by banks was stored in volatile memory. A power failure or short circuit would irreversibly wipe out account information. Recovery in such a case would be practically impossible.
The solution, therefore, is secondary memory which is persistent. Data written in a persistent medium is preserved even when power is gone. Hard drives, tape drives, SD cards, and flash memory are all examples of secondary storage that allow data to be written, stored, and retrieved over long periods of time. (Technically, ROM is also persistent, but new data cannot be written to ROM chips.) Of course, one can argue that no data storage is truly permanent. After all, hard drives fail and disks can become damaged. But we usually think of permanent as being relative to the lifetime of the computer, the data, and the user.


\include{topic_1_systems/topic_1_exercises/topic_1_exercises}