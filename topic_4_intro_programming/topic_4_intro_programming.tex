\chapter{Computational Thinking, Problem Solving, and Programming}

\section{Introduction to Programming}

\subsection*{Fundamental Operations}
When you look at how complex and rich today's software applications are, it is hard to believe that there are really only four basic operations that a computer performs. These four basic operations are add, compare, retrieve, and store. All of the amazing things that a computer does can be broken down into those four operations. The trick is that they are applied over and over again. 

In other words, the basic functions of a computer are to store values, retrieve values, add values, and compare values. That's it. In the next section, we will look at how a more complex task can be accomplished using those four operations.

\subsection*{Compound Operations}
Lets take a look at the multiplication of two numbers as an example of a compound operation. The following listing shows how a computer might accomplish this using fundamental operations.

	\begin{verbatim}
	1. Input and store A and B, the two numbers to be multiplied.
	2. Input and store C = 0, a counter variable.
	3. Input and store D = 0, the result.
	4. Add A to D. Store the value in D.
	5. Add 1 to C. Store the value in C.
	6. Compare C and B. If C is less, than B,repeat steps 4-5.
	7. If C = B, output D.
	\end{verbatim}
	
	Of course, the modern programmer does not have to worry about this level of detail. In modern programming languages, a lot of the details of these fundamental operations is abstracted away. In other words, a programmer usually just has to write a program like this:
	
	%example in C++
	\input{topic_4_intro_programming/multiplication_c++}
	
	to accomplish the same thing. (This particular example is in C++). The details of how these instructions are broken down into fundamental operations are handled by the program that processes the source code.
\subsection*{Programming Languages}

In order for any computer to work, it must be programmed. Programming a computer simply means inputting instructions that the machine is to follow so that it can solve whatever problem the programmer wants it to solve. In the early days (1940s), programming a computer meant manually wiring the machine with patch cables and wires so that data and output was channeled to where it was supposed to go. As you can imagine, such a process was time-consuming, laborious, error-prone, and expensive. In fact, once the computer was programmed to solve the problem, it could only solve that one problem. The machine had to be rewired in order to solve a new problem.

In later models, computers could be programed using a series of punched cards. A punch card contained holes that represented 1s and 0s in binary code. These holes represented either the data to be manipulated, or the wires and circuits within the computer that needed to be activated in order to process the data. The output was also written to punch cards.  This process was still laborious, but much easier than wiring the computer over again. In addition, to solve a new problem, all the user had to do was load a new set of punch cards. The more complicated the program, the more punch cards one needed. 

As computers because smaller, cheaper, and more powerful thanks to the invention of the transistor and microchip, the expectations people made on them increased as well. Computers began to be programmed not with punch cards but through a language in which a person inputed instructions using numbers and letters and these instructions were then translated into instructions the computer can process. This process is called compiling and the program that does it is called a compiler.

These rules that govern how these instructions are to be written and inputted into the computer make what is called a programming language. Programming languages come in two broad flavors - low level and high level languages. Low level languages use numbers and letters to represent instructions and data for the computer. However, these instructions are written directly for the CPU and thus can be very hard for someone not familiar with it to understand. Assembly is an example of a low level language. Here is an example of assembly code which displays the ever famous, "Hello, World!" to the screen.


%Example assmebly code
\input{topic_4_intro_programming/assembly_example}

As users made more demands on computers as their power increased, so did the complexity of the programs required. Using a low-level language like Assembly to accomplish these this was getting too complicated and error prone. Thus came the need for high-level languages. A high-level computer language also has grammar and syntax, but is much more human readable. (That does not mean easy, it just means that the instructions are much easier to understand.) Some examples of high level languages include BASIC, FORTRNAN, C++, and Java.
For comparison, here is the "Hello, World!" program written in high level language like C++. You can see that this program is a lot easier to read and understand.

\input{topic_4_intro_programming/c-plus-plus-example}

One important thing to keep in mind, though, is that computers only operate with 1s and 0s. That means that computers do not execute the instructions in a computer program directly. These instructions must first be translated into machine code so they can be executed. Machine code is the 1s and 0s that a computer understands. The software responsible for translating the source code into machine code is called a compiler.

A compiler is a program that reads the source code and outputs a file in machine code that can then be executed by the computer. A compiler only performs the translation once and the outputted program can be run indefinitely.

Another option is to use an interpreter. Programs like BASIC use an interpreter. In such a case, the lines of source code are loaded into the interpreter and they are translated "on-the-fly" into machine code. Every time the user runs the program, the source code is interpreted and translated. For this reason, interpreted languages are not used for modern applications because of performance issues. (The translation also requires system resources.)

There is a middle ground used in languages like Java which use a Virtual Machine to execute programs. When a program is written in Java, a compiler is used to translate the source code into what is called Java byte code. The Java byte code is then interpreted by the Java Virtual Machine and executed on the system. The advantage to this system is that the Java Virtual Machine is much faster at interpreting the byte code because it is already partially translated. The more important advantage is that any machine running the Java Virtual Machine can interpret the byte code properly. This allows software to be easily created for different systems such as OSX, Windows, and Linux.
%Mention Grace Hopper and compiler.
%Some videos on how computers were loaded would be a good idea.
%Adding some images of punch cards and wiring would also be helpful.

\section{Using Programming Languages}
In this section, you finally get to dirty your hands writing some computer code. Although any programming language will do, we will use JAVA because it is the recommended language for the Object Oriented option in this course.

In order to write and test programs, you need to make sure you have a compiler and an Integrated Development Environment (IDE) installed. An IDE is a program that developers use to write programs! IDEs typically have tools (hence the "integrated" part) that developers can use to make their lives easier. Your instructor will take you through the steps to install a proper development environment.

\subsection{The Nuts and Bolts of an Object Oriented Program}
Take a look at the following Java program. At first, such a program can look overwhelming. However, as you become more familiar with the basic building blocks of a programming language, you will start to see common elements that are repeated not only within a program but between different programs.
\subsubsection*{Variables}
\subsubsection*{Constants}
\subsubsection*{Operators}
\subsubsection*{Objects}
%Analyze use of variables, constants, and operators in algorithms
%Construct algorithms using loops and branching.

